from datadog_api_client.v2 import ApiClient, Configuration
from datadog_api_client.v2.api.traces_api import TracesApi
from datadog_api_client.v2.model.list_traces_request import ListTracesRequest
import pandas as pd
import os

# -------------------------
# CONFIGURAÇÃO
# -------------------------
configuration = Configuration()

configuration.servers = [
    {
        "url": "https://api.datadoghq.com",
        "description": "Datadog Public API"
    }
]

configuration.api_key["apiKeyAuth"] = os.getenv("DATADOG_API_KEY")
configuration.api_key["appKeyAuth"] = os.getenv("DATADOG_APP_KEY")

SERVICE_NAME = "meu-servico"

# FILTRO: Todos os spans com erros do serviço
# error:1 → equivale a error:true
query = f"service:{SERVICE_NAME} error:1"

# Últimas 24 horas
TIME_FROM = "now-24h"
TIME_TO = "now"

# -------------------------
# BUSCA DOS TRACES
# -------------------------
with ApiClient(configuration) as api_client:
    api_instance = TracesApi(api_client)

    body = ListTracesRequest(
        filter={
            "query": query,
            "from": TIME_FROM,
            "to": TIME_TO
        },
        page={"limit": 1000},
        sort="timestamp"
    )

    response = api_instance.list_traces(body=body)

# Extrai atributos brutos
spans = [item.attributes for item in response.data]

print(f"Total de traces com erro encontrados: {len(spans)}")


# -------------------------
# TRANSFORMAÇÃO PARA TABELA
# -------------------------
rows = []

for span in spans:
    service = span.get("service", "")
    resource = span.get("resource", "")
    http_status = None

    # A API do Datadog retorna status em "http.status_code" dentro de meta ou tags
    tags = span.get("tags", [])

    for tag in tags:
        if tag.startswith("http.status_code:"):
            http_status = tag.split(":")[1]

    rows.append({
        "service": service,
        "resource": resource,
        "status_code": http_status
    })

df = pd.DataFrame(rows)

print("\nPrévia da tabela:")
print(df.head())


# -------------------------
# EXPORTAR PARA ARQUIVO
# -------------------------
output_file = "output_traces_erros.csv"
df.to_csv(output_file, index=False)

print(f"\nArquivo gerado com sucesso: {output_file}")
