# --- Realização da Requisição ---
try:
    response = requests.post(url, json=payload, headers=headers)
    response.raise_for_status()  # Lança uma exceção para códigos de status HTTP ruins (4xx ou 5xx)

except requests.exceptions.RequestException as e:
    print(f"Erro na requisição ao Datadog: {e}")
    # Encerra o script em caso de falha na requisição
    exit()

# --- Processamento da Resposta ---
# Converte a resposta JSON em um dicionário Python
data = response.json()

# Lista para armazenar os dados extraídos
trace_data = []

# O JSON de resposta do Datadog Spans Search (v2) possui um array de 'data'
if 'data' in data:
    for span in data['data']:
        # Verifica se 'attributes' e 'tags' existem antes de tentar acessá-los
        if 'attributes' in span and 'tags' in span['attributes']:
            tags = span['attributes']['tags']
            
            # Inicializa com None para garantir que sempre haverá um valor
            status_code = tags.get('http.status_code', None)
            path = tags.get('http.url', None) or tags.get('http.route', None)
            
            # Armazena os dados, ignorando spans sem path relevante se for o objetivo
            if path:
                trace_data.append({
                    'status_code': status_code,
                    'path': path
                })

# --- Resultado ---
if trace_data:
    # Cria um DataFrame do pandas (opcional, mas muito útil para análise)
    df = pd.DataFrame(trace_data)
    
    print("✅ Dados Extraídos com Sucesso:")
    print(df)
    
    # Exemplo de como visualizar status_code e paths únicos:
    print("\n--- Paths Únicos e Contagem de Status ---")
    summary = df.groupby(['path', 'status_code']).size().reset_index(name='count')
    print(summary)

else:
    print("⚠️ Nenhuma span encontrada ou dados relevantes para extração.")
