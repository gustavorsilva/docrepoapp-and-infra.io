# --- Realização da Requisição (Mantida) ---
try:
    response = requests.post(url, json=payload, headers=headers)
    response.raise_for_status()
except requests.exceptions.RequestException as e:
    print(f"Erro na requisição ao Datadog: {e}")
    exit()

# --- Processamento da Resposta Corrigido ---
data = response.json()
trace_data = []

if 'data' in data:
    for span in data['data']:
        if 'attributes' in span and 'tags' in span['attributes']:
            
            # 1. tags_list é a lista de strings (ex: ['http.status_code:200', 'http.url:/path'])
            tags_list = span['attributes']['tags']
            
            # 2. Converte a lista de tags em um dicionário 'tags_dict'
            tags_dict = {}
            for tag_string in tags_list:
                # Encontra o primeiro ':' para dividir a chave e o valor
                if ':' in tag_string:
                    key, value = tag_string.split(':', 1) # Divide apenas no primeiro ':'
                    tags_dict[key.strip()] = value.strip()
            
            # 3. Agora, 'tags_dict' é um dicionário e podemos usar o método .get()
            
            # Extrai o status_code
            status_code = tags_dict.get('http.status_code', None)
            
            # Extrai o path, priorizando 'http.url', caindo para 'http.route'
            path = tags_dict.get('http.url', None) or tags_dict.get('http.route', None)
            
            # Armazena os dados
            if path:
                trace_data.append({
                    'status_code': status_code,
                    'path': path
                })

# --- Resultado (Mantido) ---
if trace_data:
    df = pd.DataFrame(trace_data)
    print("✅ Dados Extraídos com Sucesso:")
    print(df)
    
    print("\n--- Paths Únicos e Contagem de Status ---")
    summary = df.groupby(['path', 'status_code']).size().reset_index(name='count')
    print(summary)
else:
    print("⚠️ Nenhuma span encontrada ou dados relevantes para extração.")
