# 4. Constru√ß√£o do corpo da requisi√ß√£o
            body = SpansListRequest(
                filter=spans_query,
                sort=SpansSort("timestamp"),
                page={"limit": 100} # Define o limite de spans por requisi√ß√£o
            )
            
            # 5. Executa a chamada da API
            response = api_instance.list_spans(body=body)
            print("Busca conclu√≠da com sucesso.")
            return response
            
    except Exception as e:
        print(f"‚ùå ERRO FATAL: Falha ao chamar a API ou configurar o SDK. Detalhes: {e}")
        return None

# ===================================================================
# 2. PROCESSAMENTO E FILTRAGEM DE DADOS (COM CORRE√á√ÉO DE UNICODE)
# ===================================================================

response_data = buscar_spans_sdk()
rows = []

# ‚ö†Ô∏è 5. AJUSTE AQUI: Use os nomes exatos das chaves retornadas pelo Datadog.
campos_necessarios = [
    "status_code", 
    "mensagem", 
    "resource_name", 
    "path", 
    "date", 
    "funcional"
]

if response_data and response_data.data:
    print(f"Encontrados {len(response_data.data)} eventos para processamento.")

    # --- DEBUG: IMPRIME O PRIMEIRO EVENTO PARA VERIFICAR AS CHAVES ---
    primeiro_evento = response_data.data[0]
    atributos_debug = primeiro_evento.attributes.to_dict() if primeiro_evento.attributes else {}
    print("\n--- IN√çCIO DEBUG: CHAVES DO PRIMEIRO EVENTO ---")
    print("Verifique se seus 'campos_necessarios' batem com estas chaves:")
    # Use 'ensure_ascii=False' para ajudar a visualizar caracteres especiais no debug
    print(json.dumps(atributos_debug, indent=2, ensure_ascii=False)) 
    print("-------------------------------------------\n")
    # ----------------------------------------------------------------

    for event in response_data.data:
        attributes = event.attributes.to_dict() if event.attributes else {}
        # Tags √© um subconjunto comum onde os dados personalizados costumam estar
        tags = attributes.get('tags', {}) 
        
        # Cria um dicion√°rio √∫nico de busca
        combined_data = {**attributes, **tags} 
        
        row_data = {}
        todos_campos_presentes = True
        
        # Filtra e coleta dados
        for campo in campos_necessarios:
            valor = combined_data.get(campo)
            
            # --- üåü CORRE√á√ÉO DE UNICODE: Decodifica√ß√£o Segura ---
            if isinstance(valor, bytes):
                try:
                    # Tenta decodificar de forma segura, ignorando caracteres inv√°lidos
                    valor = valor.decode('utf-8', errors='ignore')
                except Exception:
                    # Caso a decodifica√ß√£o de bytes falhe por algum motivo
                    valor = str(valor)
            elif valor is not None:
                try:
                    # Garante que qualquer tipo de dado seja uma string UTF-8 v√°lida,
                    # descartando caracteres incompat√≠veis no processo
                    valor = str(valor).encode('utf-8', errors='ignore').decode('utf-8')
                except Exception:
                    valor = "" # Se a convers√£o falhar, use vazio
            # ----------------------------------------------------

            # Condi√ß√£o de Filtragem: Garante que o valor n√£o √© nulo e n√£o √© string vazia
            if valor is None or (isinstance(valor, (str, list, dict)) and not valor):
                todos_campos_presentes = False
                break
            
            row_data[campo] = valor

        if todos_campos_presentes:
            rows.append(row_data)

# ===================================================================
# 3. GERA√á√ÉO DO DATAFRAME
# ===================================================================

df = pd.DataFrame(rows)

df.to_excel("resultado_sdk_final.xlsx", index=False)

print("\n-----------------------------------------------------------")
print("### DataFrame Final ###")
print(df.head())
print(f"\nTotal de linhas no DataFrame final (preenchidas com 6 campos): {len(df)}")
print("\nArquivo gerado: resultado_sdk_final.xlsx")
print("-----------------------------------------------------------")
