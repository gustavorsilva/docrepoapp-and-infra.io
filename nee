from datadog_api_client.v2 import ApiClient, Configuration
from datadog_api_client.v2.api.spans_api import SpansApi
from datadog_api_client.v2.model.spans_sort import SpansSort
from datadog_api_client.v2.model.spans_list_request import SpansListRequest

# ➡️ IMPORTAÇÃO ALTERADA: Referenciando o módulo model
import datadog_api_client.v2.model as datadog_models

import pandas as pd
import requests

# ⚠️ 1. CONFIGURAÇÃO - SUBSTITUA SUAS CHAVES AQUI
DATADOG_API_KEY = "org-..."
DATADOG_APP_KEY = "org-..."

configuration = Configuration(
    api_key={"apiKeyAuth": DATADOG_API_KEY, "appKeyAuth": DATADOG_APP_KEY}
)

# --- FUNÇÃO DE BUSCA USANDO O SPANSAPI ---
def buscar_spans_sdk():
    """Busca spans do Datadog usando a classe SpansApi do SDK."""
    print("Iniciando a busca na API do Datadog...")
    try:
        with ApiClient(configuration) as api_client:
            api_instance = SpansApi(api_client)

            # 3. Definição da Query
            # ➡️ USO ALTERADO: Referenciando a classe via datadog_models
            spans_query = datadog_models.SpansEventsQuery( 
                query="service:ttk-service-bla",
                from_param="now-24h",
                to_param="now"
            )

            # 4. Construção do corpo da requisição
            body = SpansListRequest(
                filter=spans_query,
                sort=SpansSort("timestamp"),
                page={"limit": 100}
            )
            
            # 5. Executa a chamada da API
            response = api_instance.list_spans(body=body)
            print("Busca concluída com sucesso.")
            return response
            
    except requests.exceptions.RequestException as e:
        print(f"Erro de conexão: {e}")
        return None
    except Exception as e:
        print(f"Erro ao chamar a API de Spans (verifique as chaves e permissões): {e}")
        return None

# --- PROCESSAMENTO DOS DADOS ---
# (O restante do código de processamento permanece idêntico)
response_data = buscar_spans_sdk()
rows = []
campos_necessarios = [
    "status_code", "mensagem", "resource_name", 
    "path", "date", "funcional"
]

if response_data and response_data.data:
    for event in response_data.data:
        attributes = event.attributes.to_dict() if event.attributes else {}
        tags = attributes.get('tags', {})
        combined_data = {**attributes, **tags} 
        
        row_data = {}
        todos_campos_presentes = True
        
        for campo in campos_necessarios:
            valor = combined_data.get(campo)
            
            if valor is None or (isinstance(valor, str) and valor == ""):
                todos_campos_presentes = False
                break
            
            row_data[campo] = valor

        if todos_campos_presentes:
            rows.append(row_data)

# --- 6. GERAÇÃO DO DATAFRAME E ARQUIVO FINAL ---
df = pd.DataFrame(rows)

df.to_excel("resultado_sdk_alias.xlsx", index=False)

print("\n-----------------------------------------------------------")
print("### DataFrame com Linhas Preenchidas (Método SDK via Módulo) ###")
print(df.head())
print(f"\nTotal de linhas no DataFrame final: {len(df)}")
print("\nArquivo gerado: resultado_sdk_alias.xlsx")
print("-----------------------------------------------------------")
